‡¶ö‡¶Æ‡ßé‡¶ï‡¶æ‡¶∞ ‚Äî ‡¶®‡¶ø‡¶ö‡ßá ‡¶§‡ßã‡¶Æ‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø **modular (service/controller/model) pattern** ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡¶Ø‡¶º‡ßÄ ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£, ‡¶™‡ßç‡¶∞‡¶´‡ßá‡¶∂‡¶®‡¶æ‡¶≤ ‡¶è‡¶¨‡¶Ç **No-Docker** ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶è‡¶®‡ßç‡¶° ‡¶∏‡ßç‡¶ü‡¶æ‡¶∞‡ßç‡¶ü‡¶æ‡¶∞ (Express + TypeScript + Mongoose) ‚Äî ‡¶ß‡¶æ‡¶™‡ßá ‡¶ß‡¶æ‡¶™‡ßá ‡¶∞‡¶æ‡¶®/‡¶ü‡ßá‡¶∏‡ßç‡¶ü/‡¶°‡ßá‡¶™‡ßç‡¶≤‡ßü ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶á‡¶®‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶∂‡¶®‡¶∏‡¶π ‚Äî ‡¶™‡ßÅ‡¶∞‡ßã‡¶ü‡¶æ ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ ‡¶≠‡¶æ‡¶∑‡¶æ‡¶Ø‡¶º ‡¶¶‡¶ø‡¶≤‡¶æ‡¶Æ‡•§ ‡¶Ü‡¶Æ‡¶ø auth ‡¶Æ‡¶°‡¶ø‡¶â‡¶≤ (auth.model / auth.service / auth.controller / auth.route) ‡¶™‡ßÅ‡¶∞‡ßã ‡¶ï‡ßã‡¶°‡¶∏‡¶π ‡¶¶‡¶ø‡ßü‡ßá‡¶õ‡¶ø, ‡¶¨‡¶æ‡¶ï‡¶ø ‡¶Æ‡¶°‡¶ø‡¶â‡¶≤‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ ‡¶ì ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡¶ì ‡¶Ü‡¶õ‡ßá‡•§ ‡¶∂‡ßá‡¶∑‡ßá ‡¶Ü‡¶Æ‡¶ø **‡¶ï‡ßã‡¶•‡¶æ‡¶Ø‡¶º ‡¶è‡¶¨‡¶Ç ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶´‡ßç‡¶∞‡¶ø-‡¶§‡ßá ‡¶°‡ßá‡¶™‡ßç‡¶≤‡¶Ø‡¶º** ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º ‡¶∏‡ßá‡¶ü‡¶æ ‡¶¨‡¶≤‡ßá‡¶õ‡¶ø (‡¶∏‡¶Ç‡¶∂‡ßç‡¶≤‡¶ø‡¶∑‡ßç‡¶ü ‡¶∏‡ßÇ‡¶§‡ßç‡¶∞‡¶ì ‡¶∏‡¶æ‡¶á‡¶ü ‡¶•‡ßá‡¶ï‡ßá ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßá ‡¶¶‡¶ø‡ßü‡ßá‡¶õ‡¶ø)‡•§

> ‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™‡ßá ‚Äî ‡¶ï‡¶ø ‡¶™‡¶æ‡¶ö‡ßç‡¶õ‡ßã:
>
> 1. ‡¶∏‡ßç‡¶™‡¶∑‡ßç‡¶ü ‡¶´‡ßã‡¶≤‡ßç‡¶°‡¶æ‡¶∞ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ (module-wise)
> 2. ‡¶™‡ßÇ‡¶∞‡ßç‡¶£ auth ‡¶Æ‡¶°‡¶ø‡¶â‡¶≤ ‡¶ï‡ßã‡¶° (TypeScript + Mongoose + JWT cookie auth + refresh token)
> 3. ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶™‡ßã‡¶∏‡ßç‡¶ü ‡¶Æ‡¶°‡¶ø‡¶â‡¶≤ scaffold (‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá ‡¶¨‡¶æ‡ßú‡¶æ‡¶¨‡ßá)
> 4. ‡¶≤‡ßã‡¶ï‡¶æ‡¶≤‡¶ø ‡¶∞‡¶æ‡¶® ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ß‡¶æ‡¶™ (no docker)
> 5. Postman ‡¶¶‡¶ø‡ßü‡ßá ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶ö‡ßá‡¶ï/‡¶ï‡¶æ‡¶ó‡¶ú‡¶™‡¶§‡ßç‡¶∞ ‡¶§‡ßà‡¶∞‡ßÄ ‡¶ï‡¶∞‡¶¨‡ßá (collection & docs)
> 6. ‡¶´‡ßç‡¶∞‡¶ø ‡¶°‡ßá‡¶™‡ßç‡¶≤‡ßü ‡¶Ö‡¶™‡¶∂‡¶® ‡¶ì ‡¶∏‡ßç‡¶ü‡ßá‡¶™ (Render + MongoDB Atlas ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡¶æ‡¶¨) ‚Äî ‡¶∏‡ßÇ‡¶§‡ßç‡¶∞‡¶∏‡¶π‡•§ ([Render][1])

---

# ‡ßß) ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡¶æ‡¶¨‡¶ø‡¶§ ‡¶´‡ßã‡¶≤‡ßç‡¶°‡¶æ‡¶∞ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ (modular pattern)

```
server/
‚îú‚îÄ package.json
‚îú‚îÄ tsconfig.json
‚îú‚îÄ .env.example
‚îú‚îÄ README.md
‚îî‚îÄ src/
   ‚îú‚îÄ index.ts                # entry (connect DB + start server)
   ‚îú‚îÄ app.ts                  # express app + global middlewares
   ‚îú‚îÄ config/
   ‚îÇ   ‚îî‚îÄ db.ts
   ‚îú‚îÄ types/
   ‚îÇ   ‚îî‚îÄ express.d.ts        # request.user ‡¶ü‡¶æ‡¶á‡¶™ augment
   ‚îú‚îÄ modules/
   ‚îÇ   ‚îú‚îÄ auth/
   ‚îÇ   ‚îÇ  ‚îú‚îÄ auth.model.ts
   ‚îÇ   ‚îÇ  ‚îú‚îÄ auth.service.ts
   ‚îÇ   ‚îÇ  ‚îú‚îÄ auth.controller.ts
   ‚îÇ   ‚îÇ  ‚îî‚îÄ auth.routes.ts
   ‚îÇ   ‚îú‚îÄ posts/
   ‚îÇ   ‚îÇ  ‚îú‚îÄ post.model.ts
   ‚îÇ   ‚îÇ  ‚îú‚îÄ post.service.ts
   ‚îÇ   ‚îÇ  ‚îú‚îÄ post.controller.ts
   ‚îÇ   ‚îÇ  ‚îî‚îÄ post.routes.ts
   ‚îÇ   ‚îî‚îÄ ...                 # future modules: uploads, comments, admin
   ‚îú‚îÄ middlewares/
   ‚îÇ   ‚îú‚îÄ auth.middleware.ts
   ‚îÇ   ‚îî‚îÄ error.middleware.ts
   ‚îî‚îÄ utils/
      ‚îú‚îÄ jwt.ts
      ‚îî‚îÄ slugify.ts
```

---

# ‡ß®) ‡¶™‡ßç‡¶∞‡ßü‡ßã‡¶ú‡¶®‡ßÄ‡ßü ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ú (install commands)

```bash
# project root e giye
npm init -y

# core deps
npm install express mongoose dotenv cookie-parser cors helmet bcrypt jsonwebtoken express-rate-limit

# types + dev tools
npm install -D typescript ts-node-dev @types/express @types/node @types/cookie-parser @types/cors @types/jsonwebtoken @types/mongoose

# (optional, strongly recommended)
npm install zod
npm install -D @types/bcrypt
```

`package.json` scripts (recommended):

```json
"scripts": {
  "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
  "build": "tsc -p .",
  "start": "node dist/index.js"
}
```

`tsconfig.json` (‡¶∏‡¶π‡¶ú):

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  },
  "include": ["src"]
}
```

`.env.example`

```
PORT=4000
MONGO_URI=your_mongodb_atlas_connection_string
JWT_ACCESS_SECRET=change_this_access_secret
JWT_REFRESH_SECRET=change_this_refresh_secret
FRONTEND_URL=http://localhost:3000
NODE_ENV=development
```

---

# ‡ß©) ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶ï‡¶®‡¶´‡¶ø‡¶ó (DB + app entry)

`src/config/db.ts`

```ts
import mongoose from 'mongoose';

const connectDB = async () => {
  const uri = process.env.MONGO_URI || 'mongodb://localhost:27017/blogdb';
  await mongoose.connect(uri);
  console.log('MongoDB connected');
};

export default connectDB;
```

`src/index.ts`

```ts
import dotenv from 'dotenv';
dotenv.config();
import app from './app';
import connectDB from './config/db';

const PORT = process.env.PORT || 4000;

(async () => {
  try {
    await connectDB();
    app.listen(PORT, () => console.log(`Server listening on port ${PORT}`));
  } catch (err) {
    console.error('Startup error', err);
    process.exit(1);
  }
})();
```

`src/app.ts`

```ts
import express from 'express';
import helmet from 'helmet';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import rateLimit from 'express-rate-limit';
import authRoutes from './modules/auth/auth.routes';
import postRoutes from './modules/posts/post.routes';
import errorHandler from './middlewares/error.middleware';

const app = express();

app.use(helmet());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cookieParser());

app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true
}));

app.use(rateLimit({ windowMs: 15*60*1000, max: 200 }));

app.get('/', (_req, res) => res.json({ ok: true }));

app.use('/api/auth', authRoutes);
app.use('/api/posts', postRoutes);

app.use(errorHandler);

export default app;
```

---

# ‡ß™) Express Request augment (types) ‚Äî TypeScript-friendly

`src/types/express.d.ts`

```ts
import { JwtPayload } from 'jsonwebtoken';

declare global {
  namespace Express {
    interface Request {
      user?: { id: string, role?: string } | JwtPayload;
    }
  }
}
```

(ensure `tsconfig` includes `src` so compiler picks it up)

---

# ‡ß´) ‡¶™‡ßÅ‡¶∞‡ßã **Auth module** (‡¶Æ‡¶°‡¶ø‡¶â‡¶≤‡¶æ‡¶∞ ‡¶ï‡ßã‡¶° ‚Äî ‡¶ï‡¶™‡¶ø/‡¶™‡ßá‡¶∏‡ßç‡¶ü ‡¶ö‡¶æ‡¶≤‡¶æ‡¶¨‡ßá)

`src/modules/auth/auth.model.ts`

```ts
import { Schema, model, Document } from 'mongoose';

export interface IUser extends Document {
  name?: string;
  email: string;
  password?: string;
  role: 'reader' | 'author' | 'admin';
  refreshToken?: string | null; // store single refresh token (simple)
}

const UserSchema = new Schema<IUser>({
  name: String,
  email: { type: String, required: true, unique: true },
  password: String,
  role: { type: String, enum: ['reader','author','admin'], default: 'reader' },
  refreshToken: { type: String, default: null }
}, { timestamps: true });

export default model<IUser>('User', UserSchema);
```

`src/utils/jwt.ts`

```ts
import jwt from 'jsonwebtoken';

export const createAccessToken = (payload: object) => {
  return jwt.sign(payload, process.env.JWT_ACCESS_SECRET as string, { expiresIn: '15m' });
};

export const createRefreshToken = (payload: object) => {
  return jwt.sign(payload, process.env.JWT_REFRESH_SECRET as string, { expiresIn: '7d' });
};

export const verifyAccessToken = (token: string) => {
  return jwt.verify(token, process.env.JWT_ACCESS_SECRET as string);
};

export const verifyRefreshToken = (token: string) => {
  return jwt.verify(token, process.env.JWT_REFRESH_SECRET as string);
};
```

`src/modules/auth/auth.service.ts`

```ts
import User, { IUser } from './auth.model';
import bcrypt from 'bcrypt';
import { createAccessToken, createRefreshToken, verifyRefreshToken } from '../../utils/jwt';

export const registerUser = async (name: string | undefined, email: string, password: string) => {
  const existing = await User.findOne({ email });
  if (existing) throw new Error('Email already in use');

  const hashed = await bcrypt.hash(password, 10);
  const user = await User.create({ name, email, password: hashed, role: 'author' });
  return { id: user._id, email: user.email, role: user.role };
};

export const loginUser = async (email: string, password: string) => {
  const user = await User.findOne({ email });
  if (!user || !user.password) throw new Error('Invalid credentials');

  const ok = await bcrypt.compare(password, user.password);
  if (!ok) throw new Error('Invalid credentials');

  const accessToken = createAccessToken({ id: user._id, role: user.role });
  const refreshToken = createRefreshToken({ id: user._id });

  // Save refresh token (simple rotation strategy)
  user.refreshToken = refreshToken;
  await user.save();

  return { accessToken, refreshToken, user: { id: user._id, email: user.email, role: user.role } };
};

export const refreshTokens = async (token: string) => {
  try {
    const payload: any = verifyRefreshToken(token);
    const user = await User.findById(payload.id);
    if (!user || user.refreshToken !== token) throw new Error('Invalid refresh token');

    const newAccess = createAccessToken({ id: user._id, role: user.role });
    const newRefresh = createRefreshToken({ id: user._id });

    user.refreshToken = newRefresh;
    await user.save();

    return { accessToken: newAccess, refreshToken: newRefresh };
  } catch (err) {
    throw new Error('Invalid refresh token');
  }
};
```

`src/modules/auth/auth.controller.ts`

```ts
import { Request, Response } from 'express';
import * as authService from './auth.service';

export const register = async (req: Request, res: Response) => {
  try {
    const { name, email, password } = req.body;
    const user = await authService.registerUser(name, email, password);
    res.status(201).json({ message: 'User created', user });
  } catch (err: any) {
    res.status(400).json({ message: err.message || 'Register error' });
  }
};

export const login = async (req: Request, res: Response) => {
  try {
    const { email, password } = req.body;
    const { accessToken, refreshToken, user } = await authService.loginUser(email, password);

    // set cookies (httpOnly)
    res.cookie('accessToken', accessToken, {
      httpOnly: true,
      sameSite: 'lax',
      secure: process.env.NODE_ENV === 'production',
      maxAge: 15 * 60 * 1000
    });
    res.cookie('refreshToken', refreshToken, {
      httpOnly: true,
      sameSite: 'lax',
      secure: process.env.NODE_ENV === 'production',
      maxAge: 7 * 24 * 60 * 60 * 1000
    });

    res.json({ message: 'Logged in', user });
  } catch (err: any) {
    res.status(401).json({ message: err.message || 'Login failed' });
  }
};

export const refresh = async (req: Request, res: Response) => {
  try {
    const token = req.cookies?.refreshToken || req.body.refreshToken;
    if (!token) return res.status(401).json({ message: 'No refresh token' });

    const { accessToken, refreshToken } = await authService.refreshTokens(token);

    res.cookie('accessToken', accessToken, { httpOnly: true, sameSite: 'lax', secure: process.env.NODE_ENV === 'production' });
    res.cookie('refreshToken', refreshToken, { httpOnly: true, sameSite: 'lax', secure: process.env.NODE_ENV === 'production' });

    res.json({ message: 'Token refreshed' });
  } catch (err: any) {
    res.status(401).json({ message: err.message || 'Refresh failed' });
  }
};

export const logout = async (_req: Request, res: Response) => {
  // note: to be robust, clear refreshToken from DB (you can implement this)
  res.clearCookie('accessToken');
  res.clearCookie('refreshToken');
  res.json({ message: 'Logged out' });
};

export const me = async (req: Request, res: Response) => {
  if (!req.user) return res.status(401).json({ message: 'Unauthorized' });
  res.json({ user: req.user });
};
```

`src/modules/auth/auth.routes.ts`

```ts
import { Router } from 'express';
import * as authCtrl from './auth.controller';
import authMiddleware from '../../middlewares/auth.middleware';

const router = Router();

router.post('/register', authCtrl.register);
router.post('/login', authCtrl.login);
router.post('/refresh', authCtrl.refresh);
router.post('/logout', authCtrl.logout);
router.get('/me', authMiddleware, authCtrl.me);

export default router;
```

`src/middlewares/auth.middleware.ts`

```ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

export default (req: Request, res: Response, next: NextFunction) => {
  try {
    const token = req.cookies?.accessToken;
    if (!token) return res.status(401).json({ message: 'Unauthorized' });

    const payload = jwt.verify(token, process.env.JWT_ACCESS_SECRET as string) as any;
    req.user = { id: payload.id, role: payload.role };
    next();
  } catch (err) {
    return res.status(401).json({ message: 'Unauthorized' });
  }
};
```

> **Tip:** ‡¶Ü‡¶Æ‡¶ø ‡¶è‡¶á ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ü‡ßá‡¶ú‡¶ø-‡¶§‡ßá single refresh token user document-‡¶è ‡¶∞‡¶æ‡¶ñ‡ßá‡¶õ‡¶ø ‚Äî ‡¶∏‡¶π‡¶ú, ‡¶¨‡ßã‡¶ù‡¶æ ‡¶∏‡¶π‡¶ú ‡¶è‡¶¨‡¶Ç job/portfolio ‡¶ú‡¶®‡ßç‡¶Ø ‡¶™‡ßç‡¶∞‡¶ö‡ßÅ‡¶∞‡•§ Production-‡¶è ‡¶ö‡¶æ‡¶á‡¶≤‡ßá Redis-backed refresh token store ‡¶¨‡¶æ token versioning ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶¨‡ßá‡•§

---

# ‡ß¨) Posts module (‡¶∏‡¶æ‡¶Æ‡¶æ‡¶®‡ßç‡¶Ø scaffold ‚Äî ‡¶™‡¶∞‡ßá ‡¶¨‡¶æ‡ßú‡¶æ‡¶¨‡¶æ)

`src/modules/posts/post.model.ts` (‡¶∂‡ßÅ‡¶ß‡ßÅ schema)

```ts
import { Schema, model } from 'mongoose';

const PostSchema = new Schema({
  title: { type: String, required: true },
  slug: { type: String, required: true, unique: true },
  excerpt: String,
  content: String,
  author: { type: Schema.Types.ObjectId, ref: 'User' },
  tags: [String],
  coverImage: String,
  status: { type: String, enum: ['draft', 'published'], default: 'draft' }
}, { timestamps: true });

export default model('Post', PostSchema);
```

`post.service/controller/routes` ‚Äî ‡¶è‡¶ï‡¶á pattern ‡¶Ö‡¶®‡ßÅ‡¶∏‡¶∞‡¶£ ‡¶ï‡¶∞‡ßã (logic sepration in service, http logic in controller, express router file)

---

# ‡ß≠) ‡¶≤‡ßã‡¶ï‡¶æ‡¶≤‡¶ø ‡¶∞‡¶æ‡¶® (No Docker) ‚Äî ‡¶∏‡ßç‡¶ü‡ßá‡¶™-‡¶¨‡¶æ‡¶á-‡¶∏‡ßç‡¶ü‡ßá‡¶™

1. `.env` ‡¶ï‡¶™‡¶ø ‡¶ï‡¶∞‡ßã `.env.example` ‡¶•‡ßá‡¶ï‡ßá ‡¶ì ‡¶™‡ßÇ‡¶∞‡¶£ ‡¶ï‡¶∞‡ßã (MongoDB Atlas connection string ‡¶∏‡¶†‡¶ø‡¶ï ‡¶∞‡¶æ‡¶ñ‡ßã)‡•§
2. `npm install` ‡¶ö‡¶æ‡¶≤‡¶æ‡¶ì‡•§
3. `npm run dev` ‡¶ö‡¶æ‡¶≤‡¶æ‡¶ì‡•§
4. ‡¶¨‡ßç‡¶∞‡¶æ‡¶â‡¶ú‡ßá ‡¶ñ‡ßÅ‡¶≤‡ßá ‡¶¶‡ßá‡¶ñ‡ßã: `http://localhost:4000/` ‚Üí `{ok:true}`‡•§
5. Postman/Insomnia ‡¶¶‡¶ø‡ßü‡ßá API ‡¶ü‡ßá‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡ßã (‡¶®‡¶ø‡¶ö‡ßá Postman ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂ ‡¶Ü‡¶õ‡ßá)‡•§

---

# ‡ßÆ) Postman ‡¶¶‡¶ø‡ßü‡ßá ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶æ ‚Äî ‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá (‡¶ß‡¶æ‡¶™‡ßá ‡¶ß‡¶æ‡¶™‡ßá)

1. **Environment** ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßã (Name: local) ‡¶è‡¶¨‡¶Ç ‡¶≠‡ßá‡¶∞‡¶ø‡ßü‡¶æ‡¶¨‡¶≤ ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßã:

   * `baseUrl` = `http://localhost:4000`
2. **Collection** ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßã: `Blog API`

   * Request 1: `POST {{baseUrl}}/api/auth/register`

     * Body JSON: `{ "name":"Test", "email":"test@example.com", "password":"password123" }`
     * Test: expect status 201 ‚Üí add script (optional):

       ```js
       pm.test("status 201", () => pm.response.to.have.status(201));
       ```
   * Request 2: `POST {{baseUrl}}/api/auth/login`

     * Body JSON: `{ "email":"test@example.com", "password":"password123" }`
     * After run, Postman automatically stores cookies for `localhost:4000`. (Use Postman Cookies UI to inspect).
   * Request 3: `GET {{baseUrl}}/api/auth/me` (Protected)

     * Make sure to send cookies (Postman does it automatically when same host).
     * Expect 200 and user object.
   * Request 4: `POST {{baseUrl}}/api/posts` (Protected)

     * Body JSON: `{ "title":"Hello", "content":"...", "excerpt":"..." }`
     * This will use same cookie jar set by login ‚Äî if cookies missing, add header manually: `Cookie: accessToken=...; refreshToken=...` (copy from Cookies tab).
3. **Export collection** (three dots ‚Üí Export) ‚Äî ‡¶™‡ßá‡¶™‡¶æ‡¶∞‡¶™‡ßç‡¶∞‡ßÅ‡¶´ ‡¶≠‡¶æ‡¶¨‡ßá ‡¶∂‡ßá‡¶Ø‡¶º‡¶æ‡¶∞/attach ‡¶ï‡¶∞‡¶¨‡ßá ‡¶ï‡ßã‡¶®‡ßã ‡¶ú‡¶¨ ‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡¶≠‡¶ø‡¶â‡¶§‡ßá‡•§
4. **Publish docs**: Postman-‡¶è Collection ‚Üí `Publish Docs` ‡¶Ö‡¶™‡¶∂‡¶® ‡¶Ü‡¶õ‡ßá (Postman account ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá)‡•§ ‡¶è‡¶§‡ßá ‡¶è‡¶ï‡¶ü‡¶ø public docs URL ‡¶™‡¶æ‡¶¨‡ßã ‡¶Ø‡¶æ ‡¶∞‡¶ø‡¶ï‡ßç‡¶∞‡ßÅ‡¶ü‡¶æ‡¶∞/‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡¶≠‡¶ø‡¶â‡¶Ø‡¶º‡¶æ‡¶∞‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶∂‡ßá‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡•§

---

# ‡ßØ) ‡¶´‡ßç‡¶∞‡¶ø-‡¶è ‡¶°‡ßá‡¶™‡ßç‡¶≤‡ßü ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡ßÅ‡¶™‡¶æ‡¶∞‡¶ø‡¶∂ (‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§)

* **Backend (Node/Express)**: ‡¶Ü‡¶Æ‡¶ø **Render** ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡¶æ‡¶¨ ‡¶ï‡¶∞‡¶¨ ‚Äî Render-‡¶è free web services ‡¶Ü‡¶õ‡ßá (hobby/free instance) ‡¶è‡¶¨‡¶Ç ‡¶è‡¶ü‡¶ø GitHub ‡¶•‡ßá‡¶ï‡ßá auto-deploy ‡¶ï‡¶∞‡ßá; TLS ‡¶ì custom domain ‡¶∏‡¶Æ‡¶∞‡ßç‡¶•‡¶® ‡¶ï‡¶∞‡ßá‡•§ ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ Render ‡¶°‡¶ï‡¶∏ ‡¶¶‡ßá‡¶ñ‡ßã‡•§ ([Render][1])
* **Database**: **MongoDB Atlas** ‚Äî free M0 cluster (Atlas offers free shared cluster) ‚Äî ‡¶∏‡¶π‡¶ú‡ßá ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá connection string ‡¶®‡ßá‡¶¨‡ßá‡•§ ([MongoDB][2])
* **‡¶Ö‡¶≤‡ßç‡¶ü‡¶æ‡¶∞‡¶®‡ßá‡¶ü‡¶ø‡¶≠**: Railway/ Fly.io ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡¶æ‡¶¨ ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ credit/limits ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶®‡¶∏‡¶æ‡¶™‡ßá‡¶ï‡ßç‡¶∑; Railway ‡¶®‡¶§‡ßÅ‡¶® ‡¶á‡¶â‡¶ú‡¶æ‡¶∞‡¶¶‡ßá‡¶∞ free credits ‡¶¶‡ßá‡ßü‚Äî ‡¶¶‡ßá‡¶ñ‡¶¨‡ßá‡•§ ([Railway][3])
* **Frontend**: Next.js app ‡¶π‡¶≤‡ßá Vercel ‡¶∏‡¶¨‡¶ö‡ßá‡¶Ø‡¶º‡ßá ‡¶∏‡¶π‡¶ú; ‡¶§‡¶¨‡ßá Vercel serverless functions-‡¶è‡¶∞ ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶∏‡ßÄ‡¶Æ‡¶æ‡¶¨‡¶¶‡ßç‡¶ß‡¶§‡¶æ ‡¶Ü‡¶õ‡ßá ‚Äî ‡¶Ø‡¶¶‡¶ø full-blown long-lived backend ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá ‡¶§‡¶¨‡ßá Render/ Railway ‡¶≠‡¶æ‡¶≤‡ßã‡•§ ([Northflank][4])

---

# ‡ßß‡ß¶) Render-‡¶è Deploy (Quick steps)

1. GitHub ‡¶è ‡¶ï‡ßã‡¶° push ‡¶ï‡¶∞‡ßã (`main` branch)‡•§
2. Render ‡¶è account ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá ‚ÄúNew Web Service‚Äù ‚Üí connect GitHub repo‡•§
3. Build Command: `npm install && npm run build` (‡¶¨‡¶æ `npm ci && npm run build`), Start Command: `npm run start`‡•§
4. Environment: Add env vars (MONGO_URI, JWT_* etc).
5. Deploy ‡¶¨‡¶æ‡¶ü‡¶®‡ßá ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‚Äî ‡¶≤‡¶ó‡¶ó‡ßÅ‡¶≤‡ßã ‡¶¶‡ßá‡¶ñ‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá‡•§
6. DNS / custom domain ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡ßá TLS enable ‡¶ï‡¶∞‡ßã (Render free TLS)‡•§ (‡¶ì‡¶á ‡¶™‡ßá‡¶ú‡ßá ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂ ‡¶Ü‡¶õ‡ßá)‡•§ ([Render][1])

> ‡¶®‡ßã‡¶ü: Render free service limitations ‡¶Ü‡¶õ‡ßá ‚Äî hobby/free instances ‡¶ï‡¶ñ‡¶®‡ßã sleep ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá ‡¶¨‡¶æ resource ‡¶∏‡ßÄ‡¶Æ‡¶æ‡¶¨‡¶¶‡ßç‡¶ß ‡¶•‡¶æ‡¶ï‡ßá; small projects / portfolios-‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶†‡¶ø‡¶ï ‡¶Ü‡¶õ‡ßá‡•§ ([Render][1])

---

# ‡ßß‡ßß) ‡¶™‡ßç‡¶∞‡ßã‡¶°‡¶æ‡¶ï‡¶∂‡¶®‡ßá ‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶§‡ßç‡¶§‡¶æ ‡¶ì ‡¶≠‡¶æ‡¶≤‡ßã ‡¶™‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï‡¶ü‡¶ø‡¶∏ (‡¶§‡¶æ‡¶°‡¶º‡¶æ‡¶§‡¶æ‡¶°‡¶º‡¶ø ‡¶§‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ)

* **HTTPS** ‡¶¨‡¶æ‡¶ß‡ßç‡¶Ø‡¶§‡¶æ‡¶Æ‡ßÇ‡¶≤‡¶ï (Render/TLS provide ‡¶ï‡¶∞‡ßá)‡•§
* Cookie flags: `httpOnly`, `secure` (prod), `SameSite=strict/lax`‡•§
* Refresh token revoke ‡¶¨‡¶æ rotation (‡¶Ü‡¶Æ‡¶ø sample-‡¶è rotation ‡¶∞‡ßá‡¶ñ‡ßá‡¶õ‡¶ø)‡•§
* Input validation (zod) ‡¶ì output sanitization‡•§
* Rate-limit, Helmet, CORS origin whitelist‡•§
* Logging (winston/pino) + error tracking (Sentry)‡•§
* DB indexes: user.email(unique), post.slug(unique) ‡¶á‡¶§‡ßç‡¶Ø‡¶æ‡¶¶‡¶ø‡•§

---

# ‡ßß‡ß®) Interview/Resume-ready presentation (‡¶ï‡¶ø ‡¶≤‡¶ø‡¶ñ‡¶¨‡ßá)

* "Built Node.js + Express REST API with modular architecture (auth, posts), JWT-based httpOnly cookie authentication with refresh-token rotation and MongoDB Atlas persistence. Deployed backend to Render and connected to Next.js frontend on Vercel."
* GitHub repo-‡¶§‡ßá **API.md** ‡¶∞‡¶æ‡¶ñ‡ßã ‚Üí ‡¶∏‡¶¨ endpoints + example requests + sample responses + Postman collection link/README badge ‡¶∞‡¶æ‡¶ñ‡¶¨‡ßá‡•§

---

# ‡ßß‡ß©) ‡¶™‡¶∞‡¶¨‡¶∞‡ßç‡¶§‡ßÄ ‡¶Ü‡¶Æ‡¶ø ‡¶Ø‡¶æ ‡¶ï‡¶∞‡ßá ‡¶¶‡¶ø‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø (‡¶§‡ßÅ‡¶Æ‡¶æ‡¶∞ ‡¶™‡¶õ‡¶®‡ßç‡¶¶‡ßá)

* A) ‡¶§‡ßã‡¶Æ‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡ßã‡¶ú‡ßá‡¶ï‡ßç‡¶ü‡ßá **refresh-token rotation + logout that clears DB token** ‡¶™‡ßÇ‡¶∞‡ßç‡¶£‡¶≠‡¶æ‡¶¨‡ßá ‡¶á‡¶Æ‡¶™‡ßç‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶ï‡¶∞‡ßá ‡¶¶‡ßá‡¶¨‡•§
* B) **Cloudinary image upload service** (multer stream ‚Üí cloudinary) ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßá ‡¶¶‡ßá‡¶¨, ‡¶è‡¶¨‡¶Ç frontend-‡¶è ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ ‡¶¶‡ßá‡¶¨‡•§
* C) **Postman collection JSON** ‡¶Ü‡¶Æ‡¶ø ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá ‡¶¶‡ßá‡¶¨ ‡¶Ø‡¶æ‡¶§‡ßá ‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø import ‡¶ï‡¶∞‡ßá ‡¶ü‡ßá‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßã‡•§
* D) ‡¶è‡¶ï‡¶á ‡¶∏‡ßç‡¶ü‡¶æ‡¶á‡¶≤-‡¶è **frontend starter (Next.js + auth client hooks + posts list)** ‡¶¶‡¶ø‡ßü‡ßá ‡¶¶‡ßá‡¶¨ ‡¶Ø‡¶æ‡¶§‡ßá ‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶™‡ßç‡¶∞‡ßã‡¶°‡¶æ‡¶ï‡¶∂‡¶®‡ßá ‡¶≤‡¶æ‡¶ó‡¶æ‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßã‡•§

‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶ï‡ßã‡¶®‡¶ü‡¶æ ‡¶Ü‡¶ó‡ßá ‡¶ö‡¶æ‡¶ì? ‡¶Ü‡¶Æ‡¶ø ‡¶è‡¶ñ‡¶®‡¶á (A/B/C/D) ‡¶•‡ßá‡¶ï‡ßá ‡¶è‡¶ï‡¶ü‡¶æ ‡¶ï‡¶∞‡ßá ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶ï‡¶™‡¶ø-‡¶™‡ßá‡¶∏‡ßç‡¶ü‡¶Ø‡ßã‡¶ó‡ßç‡¶Ø ‡¶ï‡ßã‡¶° ‡¶¨‡ßç‡¶≤‡¶ï ‡¶™‡¶æ‡¶†‡¶ø‡ßü‡ßá ‡¶¶‡¶ø‡¶¨‡•§

‡¶∂‡ßá‡¶∑‡ßá ‡¶¶‡ßÅ‡¶ü‡ßã ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶® ‡¶∏‡ßÇ‡¶§‡ßç‡¶∞ (read before deploy): Render free web services ‡¶è‡¶¨‡¶Ç MongoDB Atlas free cluster docs‡•§ ([Render][1])

---

‡¶ö‡¶≤, ‡¶¨‡¶≤‡ßã ‡¶ï‡ßã‡¶®‡¶ü‡¶æ ‡¶Ü‡¶ó‡ßá ‡¶™‡¶õ‡¶®‡ßç‡¶¶ ‚Äî **Postman collection (C)** ‡¶¨‡¶æ‡¶®‡¶ø‡ßü‡ßá ‡¶¶‡¶ø‡¶á? ‡¶®‡¶æ ‡¶ï‡¶ø **Cloudinary upload (B)** ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶ø? ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶Ü‡¶Æ‡¶ø **refresh-token hardening (A)** ‡¶ï‡¶∞‡ßá ‡¶¶‡¶ø‡¶á ‚Äî ‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶®‡¶ø‡¶∞‡ßç‡¶ß‡¶æ‡¶∞‡¶£ ‡¶ï‡¶∞‡ßã, ‡¶Ü‡¶Æ‡¶ø ‡¶ï‡ßã‡¶°‡¶∏‡¶π ‡¶è‡¶ï‡ßá-‡¶è‡¶ï‡¶æ ‡¶ï‡¶∞‡ßá ‡¶ï‡¶∞‡ßá ‡¶¶‡ßá‡¶¨‡•§ üöÄ

[1]: https://render.com/docs/free?utm_source=chatgpt.com "Deploy for Free ‚Äì Render Docs"
[2]: https://www.mongodb.com/docs/atlas/tutorial/deploy-free-tier-cluster/?utm_source=chatgpt.com "Deploy a Free Cluster - Atlas - MongoDB Docs"
[3]: https://railway.com/pricing?utm_source=chatgpt.com "Railway Pricing and Plans"
[4]: https://northflank.com/blog/vercel-backend-limitations?utm_source=chatgpt.com "Can you use Vercel for backend? What works and when to ..."



src/modules/posts/post.model.ts (‡¶∂‡ßÅ‡¶ß‡ßÅ schema)

import { Schema, model } from 'mongoose';

const PostSchema = new Schema({
  title: { type: String, required: true },
  slug: { type: String, required: true, unique: true },
  excerpt: String,
  content: String,
  author: { type: Schema.Types.ObjectId, ref: 'User' },
  tags: [String],
  coverImage: String,
  status: { type: String, enum: ['draft', 'published'], default: 'draft' }
}, { timestamps: true });

export default model('Post', PostSchema);


post.service/controller/routes ‚Äî ‡¶è‡¶ï‡¶á pattern ‡¶Ö‡¶®‡ßÅ‡¶∏‡¶∞‡¶£ ‡¶ï‡¶∞‡ßã (logic sepration in service, http logic in controller, express router file)
