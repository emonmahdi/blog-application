
# Backend starter (Express + TypeScript + Mongoose)

This starter includes a minimal, production-minded Express + TypeScript backend with auth (register/login), Mongoose models, basic auth middleware, Dockerfile & docker-compose, and .env.example.

---

## File tree

```
server-starter/
├─ package.json
├─ tsconfig.json
├─ .env.example
├─ Dockerfile
├─ docker-compose.yml
├─ README.md
└─ src/
   ├─ index.ts
   ├─ app.ts
   ├─ config/
   │  └─ db.ts
   ├─ models/
   │  ├─ User.ts
   │  └─ Post.ts
   ├─ controllers/
   │  ├─ authController.ts
   │  └─ postController.ts
   ├─ routes/
   │  ├─ auth.ts
   │  └─ posts.ts
   ├─ middlewares/
   │  ├─ auth.ts
   │  └─ errorHandler.ts
   └─ utils/
      └─ slugify.ts
```

---

## package.json

```json
{
  "name": "blog-backend-starter",
  "version": "1.0.0",
  "private": true,
  "main": "dist/index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "build": "tsc -p .",
    "start": "node dist/index.js",
    "lint": "eslint . --ext .ts"
  },
  "dependencies": {
    "bcrypt": "^5.1.0",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-rate-limit": "^6.8.0",
    "helmet": "^6.0.1",
    "jsonwebtoken": "^9.0.0",
    "mongoose": "^7.5.0"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.0",
    "@types/cookie-parser": "^1.4.3",
    "@types/cors": "^2.8.13",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.1",
    "@types/mongoose": "^5.11.97",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.6.4"
  }
}
```

---

## tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}
```

---

## .env.example

```
PORT=4000
MONGO_URI=mongodb://mongo:27017/blogdb
JWT_ACCESS_SECRET=change_this_access_secret
JWT_REFRESH_SECRET=change_this_refresh_secret
FRONTEND_URL=http://localhost:3000
NODE_ENV=development
```

---

## Dockerfile

```Dockerfile
FROM node:20-alpine
WORKDIR /usr/src/app
COPY package*.json ./
RUN npm install --production
COPY . .
RUN npm run build
EXPOSE 4000
CMD ["node", "dist/index.js"]
```

---

## docker-compose.yml

```yaml
version: '3.8'
services:
  mongo:
    image: mongo:6
    restart: unless-stopped
    ports:
      - "27017:27017"
    volumes:
      - mongo-data:/data/db
  api:
    build: .
    command: npm run dev
    volumes:
      - ./:/usr/src/app
      - /usr/src/app/node_modules
    ports:
      - "4000:4000"
    env_file:
      - .env
    depends_on:
      - mongo

volumes:
  mongo-data:
```

---

## src/index.ts

```ts
import dotenv from 'dotenv';
dotenv.config();
import app from './app';
import connectDB from './config/db';

const PORT = process.env.PORT || 4000;

connectDB()
  .then(() => {
    app.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
    });
  })
  .catch((err) => {
    console.error('DB connection failed', err);
    process.exit(1);
  });
```

---

## src/app.ts

```ts
import express from 'express';
import helmet from 'helmet';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import rateLimit from 'express-rate-limit';
import authRoutes from './routes/auth';
import postRoutes from './routes/posts';
import errorHandler from './middlewares/errorHandler';

const app = express();

app.use(helmet());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cookieParser());

app.use(cors({ origin: process.env.FRONTEND_URL || 'http://localhost:3000', credentials: true }));

const limiter = rateLimit({ windowMs: 15 * 60 * 1000, max: 100 });
app.use(limiter);

app.get('/', (_, res) => res.send({ ok: true, message: 'API is running' }));

app.use('/api/auth', authRoutes);
app.use('/api/posts', postRoutes);

app.use(errorHandler);

export default app;
```

---

## src/config/db.ts

```ts
import mongoose from 'mongoose';

const connectDB = async () => {
  const uri = process.env.MONGO_URI as string;
  await mongoose.connect(uri);
  console.log('MongoDB connected');
};

export default connectDB;
```

---

## src/models/User.ts

```ts
import { Schema, model } from 'mongoose';

interface IUser {
  name?: string;
  email: string;
  password?: string;
  role?: 'reader' | 'author' | 'admin';
  createdAt?: Date;
}

const UserSchema = new Schema<IUser>({
  name: { type: String },
  email: { type: String, required: true, unique: true },
  password: { type: String },
  role: { type: String, enum: ['reader', 'author', 'admin'], default: 'reader' },
  createdAt: { type: Date, default: Date.now },
});

export default model<IUser>('User', UserSchema);
```

---

## src/models/Post.ts

```ts
import { Schema, model } from 'mongoose';

const PostSchema = new Schema({
  title: { type: String, required: true },
  slug: { type: String, required: true, unique: true },
  excerpt: String,
  content: String,
  author: { type: Schema.Types.ObjectId, ref: 'User' },
  tags: [String],
  coverImage: String,
  status: { type: String, enum: ['draft', 'published'], default: 'draft' },
  createdAt: { type: Date, default: Date.now },
  updatedAt: Date,
});

export default model('Post', PostSchema);
```

---

## src/controllers/authController.ts

```ts
import { Request, Response } from 'express';
import User from '../models/User';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';

const createAccessToken = (user: any) =>
  jwt.sign({ id: user._id, role: user.role }, process.env.JWT_ACCESS_SECRET as string, { expiresIn: '15m' });

const createRefreshToken = (user: any) =>
  jwt.sign({ id: user._id }, process.env.JWT_REFRESH_SECRET as string, { expiresIn: '7d' });

export const register = async (req: Request, res: Response) => {
  const { name, email, password } = req.body;
  if (!email || !password) return res.status(400).json({ message: 'Email and password required' });

  const existing = await User.findOne({ email });
  if (existing) return res.status(400).json({ message: 'Email already in use' });

  const hashed = await bcrypt.hash(password, 10);
  const user = await User.create({ name, email, password: hashed, role: 'author' });

  res.status(201).json({ message: 'User created', user: { id: user._id, email: user.email } });
};

export const login = async (req: Request, res: Response) => {
  const { email, password } = req.body;
  const user = await User.findOne({ email });
  if (!user || !user.password) return res.status(401).json({ message: 'Invalid credentials' });

  const ok = await bcrypt.compare(password, user.password);
  if (!ok) return res.status(401).json({ message: 'Invalid credentials' });

  const accessToken = createAccessToken(user);
  const refreshToken = createRefreshToken(user);

  res.cookie('accessToken', accessToken, { httpOnly: true, sameSite: 'lax', secure: process.env.NODE_ENV === 'production', maxAge: 15 * 60 * 1000 });
  res.cookie('refreshToken', refreshToken, { httpOnly: true, sameSite: 'lax', secure: process.env.NODE_ENV === 'production', maxAge: 7 * 24 * 60 * 60 * 1000 });

  res.json({ message: 'Logged in', user: { id: user._id, email: user.email, role: user.role } });
};

export const logout = async (_req: Request, res: Response) => {
  res.clearCookie('accessToken');
  res.clearCookie('refreshToken');
  res.json({ message: 'Logged out' });
};
```

---

## src/controllers/postController.ts

```ts
import { Request, Response } from 'express';
import Post from '../models/Post';
import slugify from '../utils/slugify';

export const createPost = async (req: Request, res: Response) => {
  const { title, excerpt, content, tags } = req.body;
  const slug = slugify(title);
  const post = await Post.create({ title, slug, excerpt, content, tags });
  res.status(201).json(post);
};

export const listPosts = async (_req: Request, res: Response) => {
  const posts = await Post.find().sort({ createdAt: -1 }).limit(20);
  res.json(posts);
};

export const getPost = async (req: Request, res: Response) => {
  const { slug } = req.params;
  const post = await Post.findOne({ slug });
  if (!post) return res.status(404).json({ message: 'Not found' });
  res.json(post);
};
```

---

## src/routes/auth.ts

```ts
import { Router } from 'express';
import { register, login, logout } from '../controllers/authController';

const router = Router();

router.post('/register', register);
router.post('/login', login);
router.post('/logout', logout);

export default router;
```

---

## src/routes/posts.ts

```ts
import { Router } from 'express';
import { createPost, listPosts, getPost } from '../controllers/postController';
import authMiddleware from '../middlewares/auth';

const router = Router();

router.get('/', listPosts);
router.get('/:slug', getPost);
router.post('/', authMiddleware, createPost);

export default router;
```

---

## src/middlewares/auth.ts

```ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

interface JwtPayload {
  id: string;
  role?: string;
}

const authMiddleware = (req: Request & { user?: any }, res: Response, next: NextFunction) => {
  try {
    const token = req.cookies?.accessToken;
    if (!token) return res.status(401).json({ message: 'Unauthorized' });
    const payload = jwt.verify(token, process.env.JWT_ACCESS_SECRET as string) as JwtPayload;
    req.user = payload;
    next();
  } catch (err) {
    return res.status(401).json({ message: 'Unauthorized' });
  }
};

export default authMiddleware;
```

---

## src/middlewares/errorHandler.ts

```ts
import { NextFunction, Request, Response } from 'express';

export default function errorHandler(err: any, _req: Request, res: Response, _next: NextFunction) {
  console.error(err);
  res.status(err.status || 500).json({ message: err.message || 'Internal Server Error' });
}
```

---

## src/utils/slugify.ts

```ts
export default function slugify(text: string) {
  return text
    .toString()
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-')
    .replace(/[^a-z0-9\-]/g, '')
    .replace(/-+/g, '-');
}
```

---

## README.md (short)

```
# Blog Backend Starter

## Quick start

1. copy `.env.example` to `.env` and fill values
2. run with docker-compose: `docker-compose up --build`
3. or run locally:
   - `npm install` in project root
   - `npm run dev`

API endpoints:
- GET / => health
- POST /api/auth/register
- POST /api/auth/login
- POST /api/auth/logout
- GET /api/posts
- GET /api/posts/:slug
- POST /api/posts (protected)


Customize and extend: add uploads (Cloudinary), comments, tests, and more.
```

---

Happy hacking! Modify the starter as you like — tell me if you want a matching Next.js frontend starter next.



আমি তোমার জন্য **Backend starter (Express + TypeScript + Mongoose)** ক্যানভাসে তৈরি করে দিলাম — এতে আছে: প্রজেক্ট ফাইল-ট্রি, `package.json`, `tsconfig.json`, `.env.example`, `Dockerfile`, `docker-compose.yml`, এবং `src/`-এর সব মূল ফাইল (index, app, config/db, models, controllers, routes, middleware, utils) — সবকিছু কপি-পেস্ট করে তুমিই চালিয়ে দিতে পারবে। ✅

কী করবে এখন (দ্রুত টিপস — বাংলা):

1. প্রজেক্ট ফোল্ডার ক্লোন / কপি করে `.env.example` থেকে `.env` বানাও এবং ভ্যালু পূরণ করো (MONGO_URI ইত্যাদি)।
2. লোকাল ডেভে চালাতে: `npm install` → `npm run dev`। (কিন্তু docker-compose থাকলে `docker-compose up --build` করলেই mongo ও api একসাথে চলবে)।
3. ফ্রন্টএন্ড হিসেবে তুমার Next.js অ্যাপ থেকে `http://localhost:4000/api/...` এ কল করো (অরিজিন কনফিগার করা আছে)।
4. প্রয়োজনে আমি এখনই `Cloudinary` আপলোড, refresh-token flow, বা JWT cookie rotation যোগ করে দেব — বলো কোনটা আগে দরকার।

চাওলে আমি এখন এই স্টার্টারে:

* Refresh-token endpoint + token rotation যোগ করে দিতে পারি, বা
* Cloudinary আপলোড সার্ভিস + multer integration যোগ করে দেব, বা
* পুরো auth flow-র জন্য Redis-based session/refresh-token storage যোগ করে দেব।

কোনটা আগে লাগবে — বলো; আমি সোজাসুজি কোড যোগ করে দেব। 🚀
