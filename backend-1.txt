
# Backend starter (Express + TypeScript + Mongoose)

This starter includes a minimal, production-minded Express + TypeScript backend with auth (register/login), Mongoose models, basic auth middleware, Dockerfile & docker-compose, and .env.example.

---

## File tree

```
server-starter/
‚îú‚îÄ package.json
‚îú‚îÄ tsconfig.json
‚îú‚îÄ .env.example
‚îú‚îÄ Dockerfile
‚îú‚îÄ docker-compose.yml
‚îú‚îÄ README.md
‚îî‚îÄ src/
   ‚îú‚îÄ index.ts
   ‚îú‚îÄ app.ts
   ‚îú‚îÄ config/
   ‚îÇ  ‚îî‚îÄ db.ts
   ‚îú‚îÄ models/
   ‚îÇ  ‚îú‚îÄ User.ts
   ‚îÇ  ‚îî‚îÄ Post.ts
   ‚îú‚îÄ controllers/
   ‚îÇ  ‚îú‚îÄ authController.ts
   ‚îÇ  ‚îî‚îÄ postController.ts
   ‚îú‚îÄ routes/
   ‚îÇ  ‚îú‚îÄ auth.ts
   ‚îÇ  ‚îî‚îÄ posts.ts
   ‚îú‚îÄ middlewares/
   ‚îÇ  ‚îú‚îÄ auth.ts
   ‚îÇ  ‚îî‚îÄ errorHandler.ts
   ‚îî‚îÄ utils/
      ‚îî‚îÄ slugify.ts
```

---

## package.json

```json
{
  "name": "blog-backend-starter",
  "version": "1.0.0",
  "private": true,
  "main": "dist/index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "build": "tsc -p .",
    "start": "node dist/index.js",
    "lint": "eslint . --ext .ts"
  },
  "dependencies": {
    "bcrypt": "^5.1.0",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-rate-limit": "^6.8.0",
    "helmet": "^6.0.1",
    "jsonwebtoken": "^9.0.0",
    "mongoose": "^7.5.0"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.0",
    "@types/cookie-parser": "^1.4.3",
    "@types/cors": "^2.8.13",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.1",
    "@types/mongoose": "^5.11.97",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.6.4"
  }
}
```

---

## tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}
```

---

## .env.example

```
PORT=4000
MONGO_URI=mongodb://mongo:27017/blogdb
JWT_ACCESS_SECRET=change_this_access_secret
JWT_REFRESH_SECRET=change_this_refresh_secret
FRONTEND_URL=http://localhost:3000
NODE_ENV=development
```

---

## Dockerfile

```Dockerfile
FROM node:20-alpine
WORKDIR /usr/src/app
COPY package*.json ./
RUN npm install --production
COPY . .
RUN npm run build
EXPOSE 4000
CMD ["node", "dist/index.js"]
```

---

## docker-compose.yml

```yaml
version: '3.8'
services:
  mongo:
    image: mongo:6
    restart: unless-stopped
    ports:
      - "27017:27017"
    volumes:
      - mongo-data:/data/db
  api:
    build: .
    command: npm run dev
    volumes:
      - ./:/usr/src/app
      - /usr/src/app/node_modules
    ports:
      - "4000:4000"
    env_file:
      - .env
    depends_on:
      - mongo

volumes:
  mongo-data:
```

---

## src/index.ts

```ts
import dotenv from 'dotenv';
dotenv.config();
import app from './app';
import connectDB from './config/db';

const PORT = process.env.PORT || 4000;

connectDB()
  .then(() => {
    app.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
    });
  })
  .catch((err) => {
    console.error('DB connection failed', err);
    process.exit(1);
  });
```

---

## src/app.ts

```ts
import express from 'express';
import helmet from 'helmet';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import rateLimit from 'express-rate-limit';
import authRoutes from './routes/auth';
import postRoutes from './routes/posts';
import errorHandler from './middlewares/errorHandler';

const app = express();

app.use(helmet());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cookieParser());

app.use(cors({ origin: process.env.FRONTEND_URL || 'http://localhost:3000', credentials: true }));

const limiter = rateLimit({ windowMs: 15 * 60 * 1000, max: 100 });
app.use(limiter);

app.get('/', (_, res) => res.send({ ok: true, message: 'API is running' }));

app.use('/api/auth', authRoutes);
app.use('/api/posts', postRoutes);

app.use(errorHandler);

export default app;
```

---

## src/config/db.ts

```ts
import mongoose from 'mongoose';

const connectDB = async () => {
  const uri = process.env.MONGO_URI as string;
  await mongoose.connect(uri);
  console.log('MongoDB connected');
};

export default connectDB;
```

---

## src/models/User.ts

```ts
import { Schema, model } from 'mongoose';

interface IUser {
  name?: string;
  email: string;
  password?: string;
  role?: 'reader' | 'author' | 'admin';
  createdAt?: Date;
}

const UserSchema = new Schema<IUser>({
  name: { type: String },
  email: { type: String, required: true, unique: true },
  password: { type: String },
  role: { type: String, enum: ['reader', 'author', 'admin'], default: 'reader' },
  createdAt: { type: Date, default: Date.now },
});

export default model<IUser>('User', UserSchema);
```

---

## src/models/Post.ts

```ts
import { Schema, model } from 'mongoose';

const PostSchema = new Schema({
  title: { type: String, required: true },
  slug: { type: String, required: true, unique: true },
  excerpt: String,
  content: String,
  author: { type: Schema.Types.ObjectId, ref: 'User' },
  tags: [String],
  coverImage: String,
  status: { type: String, enum: ['draft', 'published'], default: 'draft' },
  createdAt: { type: Date, default: Date.now },
  updatedAt: Date,
});

export default model('Post', PostSchema);
```

---

## src/controllers/authController.ts

```ts
import { Request, Response } from 'express';
import User from '../models/User';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';

const createAccessToken = (user: any) =>
  jwt.sign({ id: user._id, role: user.role }, process.env.JWT_ACCESS_SECRET as string, { expiresIn: '15m' });

const createRefreshToken = (user: any) =>
  jwt.sign({ id: user._id }, process.env.JWT_REFRESH_SECRET as string, { expiresIn: '7d' });

export const register = async (req: Request, res: Response) => {
  const { name, email, password } = req.body;
  if (!email || !password) return res.status(400).json({ message: 'Email and password required' });

  const existing = await User.findOne({ email });
  if (existing) return res.status(400).json({ message: 'Email already in use' });

  const hashed = await bcrypt.hash(password, 10);
  const user = await User.create({ name, email, password: hashed, role: 'author' });

  res.status(201).json({ message: 'User created', user: { id: user._id, email: user.email } });
};

export const login = async (req: Request, res: Response) => {
  const { email, password } = req.body;
  const user = await User.findOne({ email });
  if (!user || !user.password) return res.status(401).json({ message: 'Invalid credentials' });

  const ok = await bcrypt.compare(password, user.password);
  if (!ok) return res.status(401).json({ message: 'Invalid credentials' });

  const accessToken = createAccessToken(user);
  const refreshToken = createRefreshToken(user);

  res.cookie('accessToken', accessToken, { httpOnly: true, sameSite: 'lax', secure: process.env.NODE_ENV === 'production', maxAge: 15 * 60 * 1000 });
  res.cookie('refreshToken', refreshToken, { httpOnly: true, sameSite: 'lax', secure: process.env.NODE_ENV === 'production', maxAge: 7 * 24 * 60 * 60 * 1000 });

  res.json({ message: 'Logged in', user: { id: user._id, email: user.email, role: user.role } });
};

export const logout = async (_req: Request, res: Response) => {
  res.clearCookie('accessToken');
  res.clearCookie('refreshToken');
  res.json({ message: 'Logged out' });
};
```

---

## src/controllers/postController.ts

```ts
import { Request, Response } from 'express';
import Post from '../models/Post';
import slugify from '../utils/slugify';

export const createPost = async (req: Request, res: Response) => {
  const { title, excerpt, content, tags } = req.body;
  const slug = slugify(title);
  const post = await Post.create({ title, slug, excerpt, content, tags });
  res.status(201).json(post);
};

export const listPosts = async (_req: Request, res: Response) => {
  const posts = await Post.find().sort({ createdAt: -1 }).limit(20);
  res.json(posts);
};

export const getPost = async (req: Request, res: Response) => {
  const { slug } = req.params;
  const post = await Post.findOne({ slug });
  if (!post) return res.status(404).json({ message: 'Not found' });
  res.json(post);
};
```

---

## src/routes/auth.ts

```ts
import { Router } from 'express';
import { register, login, logout } from '../controllers/authController';

const router = Router();

router.post('/register', register);
router.post('/login', login);
router.post('/logout', logout);

export default router;
```

---

## src/routes/posts.ts

```ts
import { Router } from 'express';
import { createPost, listPosts, getPost } from '../controllers/postController';
import authMiddleware from '../middlewares/auth';

const router = Router();

router.get('/', listPosts);
router.get('/:slug', getPost);
router.post('/', authMiddleware, createPost);

export default router;
```

---

## src/middlewares/auth.ts

```ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

interface JwtPayload {
  id: string;
  role?: string;
}

const authMiddleware = (req: Request & { user?: any }, res: Response, next: NextFunction) => {
  try {
    const token = req.cookies?.accessToken;
    if (!token) return res.status(401).json({ message: 'Unauthorized' });
    const payload = jwt.verify(token, process.env.JWT_ACCESS_SECRET as string) as JwtPayload;
    req.user = payload;
    next();
  } catch (err) {
    return res.status(401).json({ message: 'Unauthorized' });
  }
};

export default authMiddleware;
```

---

## src/middlewares/errorHandler.ts

```ts
import { NextFunction, Request, Response } from 'express';

export default function errorHandler(err: any, _req: Request, res: Response, _next: NextFunction) {
  console.error(err);
  res.status(err.status || 500).json({ message: err.message || 'Internal Server Error' });
}
```

---

## src/utils/slugify.ts

```ts
export default function slugify(text: string) {
  return text
    .toString()
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-')
    .replace(/[^a-z0-9\-]/g, '')
    .replace(/-+/g, '-');
}
```

---

## README.md (short)

```
# Blog Backend Starter

## Quick start

1. copy `.env.example` to `.env` and fill values
2. run with docker-compose: `docker-compose up --build`
3. or run locally:
   - `npm install` in project root
   - `npm run dev`

API endpoints:
- GET / => health
- POST /api/auth/register
- POST /api/auth/login
- POST /api/auth/logout
- GET /api/posts
- GET /api/posts/:slug
- POST /api/posts (protected)


Customize and extend: add uploads (Cloudinary), comments, tests, and more.
```

---

Happy hacking! Modify the starter as you like ‚Äî tell me if you want a matching Next.js frontend starter next.



‡¶Ü‡¶Æ‡¶ø ‡¶§‡ßã‡¶Æ‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø **Backend starter (Express + TypeScript + Mongoose)** ‡¶ï‡ßç‡¶Ø‡¶æ‡¶®‡¶≠‡¶æ‡¶∏‡ßá ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá ‡¶¶‡¶ø‡¶≤‡¶æ‡¶Æ ‚Äî ‡¶è‡¶§‡ßá ‡¶Ü‡¶õ‡ßá: ‡¶™‡ßç‡¶∞‡¶ú‡ßá‡¶ï‡ßç‡¶ü ‡¶´‡¶æ‡¶á‡¶≤-‡¶ü‡ßç‡¶∞‡¶ø, `package.json`, `tsconfig.json`, `.env.example`, `Dockerfile`, `docker-compose.yml`, ‡¶è‡¶¨‡¶Ç `src/`-‡¶è‡¶∞ ‡¶∏‡¶¨ ‡¶Æ‡ßÇ‡¶≤ ‡¶´‡¶æ‡¶á‡¶≤ (index, app, config/db, models, controllers, routes, middleware, utils) ‚Äî ‡¶∏‡¶¨‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶ï‡¶™‡¶ø-‡¶™‡ßá‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡ßá ‡¶§‡ßÅ‡¶Æ‡¶ø‡¶á ‡¶ö‡¶æ‡¶≤‡¶ø‡¶Ø‡¶º‡ßá ‡¶¶‡¶ø‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá‡•§ ‚úÖ

‡¶ï‡ßÄ ‡¶ï‡¶∞‡¶¨‡ßá ‡¶è‡¶ñ‡¶® (‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶ü‡¶ø‡¶™‡¶∏ ‚Äî ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ):

1. ‡¶™‡ßç‡¶∞‡¶ú‡ßá‡¶ï‡ßç‡¶ü ‡¶´‡ßã‡¶≤‡ßç‡¶°‡¶æ‡¶∞ ‡¶ï‡ßç‡¶≤‡ßã‡¶® / ‡¶ï‡¶™‡¶ø ‡¶ï‡¶∞‡ßá `.env.example` ‡¶•‡ßá‡¶ï‡ßá `.env` ‡¶¨‡¶æ‡¶®‡¶æ‡¶ì ‡¶è‡¶¨‡¶Ç ‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡ßÅ ‡¶™‡ßÇ‡¶∞‡¶£ ‡¶ï‡¶∞‡ßã (MONGO_URI ‡¶á‡¶§‡ßç‡¶Ø‡¶æ‡¶¶‡¶ø)‡•§
2. ‡¶≤‡ßã‡¶ï‡¶æ‡¶≤ ‡¶°‡ßá‡¶≠‡ßá ‡¶ö‡¶æ‡¶≤‡¶æ‡¶§‡ßá: `npm install` ‚Üí `npm run dev`‡•§ (‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ docker-compose ‡¶•‡¶æ‡¶ï‡¶≤‡ßá `docker-compose up --build` ‡¶ï‡¶∞‡¶≤‡ßá‡¶á mongo ‡¶ì api ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá ‡¶ö‡¶≤‡¶¨‡ßá)‡•§
3. ‡¶´‡ßç‡¶∞‡¶®‡ßç‡¶ü‡¶è‡¶®‡ßç‡¶° ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá ‡¶§‡ßÅ‡¶Æ‡¶æ‡¶∞ Next.js ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™ ‡¶•‡ßá‡¶ï‡ßá `http://localhost:4000/api/...` ‡¶è ‡¶ï‡¶≤ ‡¶ï‡¶∞‡ßã (‡¶Ö‡¶∞‡¶ø‡¶ú‡¶ø‡¶® ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶Ü‡¶õ‡ßá)‡•§
4. ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®‡ßá ‡¶Ü‡¶Æ‡¶ø ‡¶è‡¶ñ‡¶®‡¶á `Cloudinary` ‡¶Ü‡¶™‡¶≤‡ßã‡¶°, refresh-token flow, ‡¶¨‡¶æ JWT cookie rotation ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßá ‡¶¶‡ßá‡¶¨ ‚Äî ‡¶¨‡¶≤‡ßã ‡¶ï‡ßã‡¶®‡¶ü‡¶æ ‡¶Ü‡¶ó‡ßá ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞‡•§

‡¶ö‡¶æ‡¶ì‡¶≤‡ßá ‡¶Ü‡¶Æ‡¶ø ‡¶è‡¶ñ‡¶® ‡¶è‡¶á ‡¶∏‡ßç‡¶ü‡¶æ‡¶∞‡ßç‡¶ü‡¶æ‡¶∞‡ßá:

* Refresh-token endpoint + token rotation ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßá ‡¶¶‡¶ø‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø, ‡¶¨‡¶æ
* Cloudinary ‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶ø‡¶∏ + multer integration ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßá ‡¶¶‡ßá‡¶¨, ‡¶¨‡¶æ
* ‡¶™‡ßÅ‡¶∞‡ßã auth flow-‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø Redis-based session/refresh-token storage ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßá ‡¶¶‡ßá‡¶¨‡•§

‡¶ï‡ßã‡¶®‡¶ü‡¶æ ‡¶Ü‡¶ó‡ßá ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá ‚Äî ‡¶¨‡¶≤‡ßã; ‡¶Ü‡¶Æ‡¶ø ‡¶∏‡ßã‡¶ú‡¶æ‡¶∏‡ßÅ‡¶ú‡¶ø ‡¶ï‡ßã‡¶° ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßá ‡¶¶‡ßá‡¶¨‡•§ üöÄ
